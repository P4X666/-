<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>轮播图练习</title>
    <link rel="stylesheet" href="../elementUi.css">
    <link rel="stylesheet" href="./Carousel.css" />
    <script src="./Carousel.js"></script>
</head>

<body>

    <div id="container">
        <div class="button">
            <div class="pre"></div>
            <div class="next"></div>
        </div>
        <ul class="list animation" style="height: 400px;">
            <li>0<img src="../img1.image"></li>
            <li>1<img src="../img2.image"></li>
            <li>2<img src="../img3.image"></li>
            <li>3<img src="../img4.image"></li>
        </ul>
        <ul class="dots">
            <li attr="0" class="active"></li>
            <li attr="1"></li>
            <li attr="2"></li>
            <li attr="3"></li>
        </ul>
    </div>
    <script>
        const interval = 2000 //时间间隔
        const width = 500// 轮播图的宽度
        let intervalId=null //  定时器
        // 图片集合
        const lists = document.querySelector(".list")
        const listItem = Array.from(lists.children)
        // 圆点集合
        const dots = document.querySelector(".dots")
        const dot = Array.from(dots.children)
        // 前后按钮集合
        const button = document.querySelector(".button")
        let current = 0, max = listItem.length
        // 存储圆点的状态
        const dotSelect = {
            preDot: dot[0],
            currentDot: dot[0]
        }
        let timeOut = null
        const animationInOrder = [max - 1, 0] // 初始化 拥有动画的两个节点
        const listOrder = [] // 节点位置的映射
        // li 预处理
        const half = max / 2
        pretreatment()
        /**
        *   轮播图的状态初始化
        **/
        function pretreatment() {

            for (let i = 0; i < max; i++) {
                const item = listItem[i];
                listOrder.push(i)
                // 以第一个元素为中心对称 右侧为正的，左侧为负的
                let left = i > half ? (i - max) * width : i * width
                if (i == 0) {
                    item.classList.add("is-active")
                    item.classList.add("is-animating")
                }

                if (i == max - 1) {
                    item.classList.add("is-animating")
                }
                item.style.transform = `translateX(${left}px)`
                item.classList.add("el-carousel__item")
            }
        }

        button.addEventListener("click", function (e) {

            const target = e.target
            if (target.className == "next") {
                // 到下一页
                goNext()
            }
            if (target.className == "pre") {
                // 到上一页
                goPre()
            }
        })
        
        function goNext() {
            current++
            if (current == max) {
                current = 0
            }
            handleLi(current, true)
            handleDot(current)
        }

        function goPre() {
            current--
            if (current < 0) {
                current = max - 1
            }
            handleLi(current, false)
            handleDot(current)
        }

        function handleLi(current, isNext) {
            // 处理节点的class
            if (isNext) {
                if (current == 0 && animationInOrder[1] == 0) {// 判断是不是在第一个和最后一个的交界处
                    const preLi = animationInOrder[0]
                    listItem[preLi].classList.remove("is-active")
                    listItem[current].classList.add("is-active")
                } else {
                    const pre_preLi = animationInOrder.shift()
                    const preLi = animationInOrder[0]

                    listItem[pre_preLi].classList.remove("is-animating")
                    listItem[preLi].classList.remove("is-active")
                    listItem[current].classList.add("is-active")
                    listItem[current].classList.add("is-animating")

                    animationInOrder.push(current)
                }

                const showNode = listOrder.shift()
                listOrder.push(showNode)
            } else {
                if (current == max - 1 && animationInOrder[1] == 0) {// 判断是不是在第一个和最后一个的交界处
                    const preLi = animationInOrder[1]
                    listItem[preLi].classList.remove("is-active")
                    listItem[current].classList.add("is-active")
                } else {
                    const pre_preLi = animationInOrder.pop()
                    const preLi = animationInOrder[0]
                    listItem[pre_preLi].classList.remove("is-animating")
                    listItem[preLi].classList.remove("is-active")
                    listItem[current].classList.add("is-active")
                    listItem[current].classList.add("is-animating")
                    animationInOrder.unshift(current)
                }

                const showNode = listOrder.pop()
                listOrder.unshift(showNode)
            }
            translateLi()
        }
        // 处理节点的 translateX ， listOrder 的第一个永远是显示的那一个节点
        function translateLi() {
            for (let i = 0; i < max; i++) {
                let left = i > half ? (i - max) * width : i * width
                listItem[listOrder[i]].style.transform = `translateX(${left}px)`
            }
        }
        function handleDot(current) {
            current = current % 4
            dotSelect.preDot = dotSelect.currentDot
            dotSelect.currentDot = dot[current]
            dotSelect.currentDot.className = "active"
            dotSelect.preDot.className = ""
        }
        function autoPlay() {
            if(intervalId){
                removeAnima()
            }
            intervalId=setInterval(() => {
                goNext()
            }, interval);
        }
        autoPlay() 


        function removeAnima(){
            clearInterval(intervalId)
            intervalId=null
        }
        const container=document.querySelector("#container")
        // 当鼠标悬停在父盒子上时，停止动画
        container.addEventListener("mouseover",function(e){
            removeAnima()
        })
        // 当鼠标悬停在父盒子上时，开始动画
        container.addEventListener("mouseout",function(e){
            autoPlay() 
        })
    </script>
</body>

</html>